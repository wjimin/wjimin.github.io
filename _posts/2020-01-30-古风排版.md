中国的古人写文字，是从右向左竖向排版的。本题就请你编写程序，把一段文字按古风排版。

### 输入格式：

输入在第一行给出一个正整数N（<100），是每一列的字符数。第二行给出一个长度不超过1000的非空字符串，以回车结束。

### 输出格式：

按古风格式排版给定的字符串，每列N个字符（除了最后一列可能不足N个）。

### 输入样例：

4

This is a test case

      
    
输出样例：



asa T

st ih

e tsi

 ce s
 
 ### 分析：
 题意比较明确，对于一行字符串而言当我们决定每列的字符的个数就可以得到需要的行数。需要注意的是最后一列可能不足N个，因此我们需要用空格补充。下面以4*5的1~20的20个数字为例简单分析一下。 

```c
//原始序列
0   0  1  2  3
0   1  2  3  4 
1   5  6  7  8
2   9 10 11 12 
3  13 14 15 16
4  17 18 19 20
//排版后
17(4,0) 13(3,0)  9(2,0) 5(1,0) 1(0,0) 
18(4,1) 14(3,1) 10(2,1) 6(1,1) 2(0,1) 
19(4,2) 15(3,2) 11(2,2) 7(1,2) 3(0,2) 
20(4,3) 16(3,3) 12(2,3) 8(1,3) 4(0,3)

```
我们很容易想到用二维数组实现原始数据的存储，对于输出的数据而言，如果我们用i,j表示矩阵的行和列，那么经过排版后的数据刚好是原始数据顺时针旋转了90度，排版后的第（i,j）位置的数据是原始（j,i)

### 下面上代码：

```c
#include<stdio.h>
#include<string.h>
int main()
{
    char a[105][105];
    memset(a,' ',sizeof(a)) ;//方便起见先将数组初始化为空格
    int n,i,j,m=0;
    int k=0;
    scanf("%d",&n);
    getchar();//吞掉回车
    char s[1005];
    gets(s);
    int len=strlen(s);
    m=len/n+(len%n ? 1 : 0 );//获取行数
    for(i=m-1; i>=0; i--)
    {
        for(j=0; j<n; j++)
        {
            if(k==len)
                break;
            a[j][i]=s[k++];
        }
        if(k==len)
            break;
    }
    for(i=0; i<n; i++)
    {
        for(j=0; j<m; j++)
        {
            printf("%c",a[i][j]);
        }
        printf("\n");
    }
    return 0;
}
```


