一天蒜头君掉进了一个迷宫里面，蒜头君想逃出去，可怜的蒜头君连迷宫是否有能逃出去的路都不知道。

看在蒜头君这么可怜的份上，就请聪明的你告诉蒜头君是否有可以逃出去的路。

### 输入格式

第一行输入两个整数 n 和 m，表示这是一个 n×m 的迷宫。

接下来的输入一个 n 行 m列的迷宫。其中 'S' 表示蒜头君的位置，'*'表示墙，蒜头君无法通过，'.'表示路，蒜头君可以通过'.'移动，'T'表示迷宫的出口（蒜头君每次只能移动到四个与他相邻的位置——上，下，左，右）。

### 输出格式

输出一个字符串，如果蒜头君可以逃出迷宫输出"yes"，否则输出"no"。

### 数据范围

1≤n,m≤10。

输出时每行末尾的多余空格，不影响答案正确性

### 样例输入1



```c
3 4
S**.
..*.
***T
```

### 样例输出1

```c
no
```

### 样例输入2

```c
3 4
S**.
....
***T
```

### 样例输出2

```c
yes
```
下面先附上dfs的模板，递归比较难以理解，关键在于练习，练的多了也就会了。

```c
void dfs()//参数用来表示状态  
{  
    if(到达终点状态)  
    {  
        ...//根据题意添加  
        return;  
    }  
    if(越界或者是不合法状态)  
        return;  
    if(特殊状态)//剪枝
        return ;
    for(扩展方式)  
    {  
        if(扩展方式所达到状态合法)  
        {  
            修改操作;//根据题意来添加  
            标记；  
            dfs（）；  
            (还原标记)；  
            //是否还原标记根据题意  
            //如果加上（还原标记）就是 回溯法  
        }  
 
    }  
}  
```
有了模板之后可以先看一下代码再试着在脑子里走一遍程序，下面写的代码算是比较容易理解的形式了。

```c
#include<stdio.h>
#include<string.h>
//为了方便使用了较多的全局变量
int n, m;
char s[15][15];//地图
int vis[15][15];//表示地图某个点是否走过0表示没有走过，1表示走过
int dir[4][2] = {{1, 0}, {-1, 0}, {0, -1}, {0, 1}};//表示四个方向
int flag;//用来标记能否到达目的地
void dfs(int x,int y)
{
	if(s[x][y]=='T')//能到达标记为1
	{
		flag=1;
		return;
	}

	for (int i=0;i<4;i++)//四个方向遍历
	{
		int tx= x+dir[i][0];
		int ty=y+dir[i][1];
		//此点坐标没有被访问过&&下标合法&&此点不是路障
		if (!vis[tx][ty]&&0<=tx&&tx<m&&0<=ty&&ty<n&&s[x][y]!='*')
		{
		    vis[tx][ty]=1;
			dfs(tx,ty);
			vis[tx][ty]=0;
		}
	}
}
int main()
{
	scanf("%d%d",&m,&n);
	for (int i=0; i<m;i++)
	{
		scanf("%s",s[i]);//思考一下
	}
	for (int i=0;i<m;i++)
	{
		for (int j=0;j<n;j++)
		{
			if (s[i][j]=='S')//遍历找到起点坐标
			{
				dfs(i,j);
				break;//小优化
			}
		}
	}
	if (flag)//真
	{
		printf("yes\n");
	}
	else
	{
		printf("no\n");
	}
	return 0;
}
```

建议学习dfs的同学可以先了解一下函数递归和二叉树的遍历的内容。
