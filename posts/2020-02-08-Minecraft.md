Minecraft 是一个几乎无所不能的沙盒游戏，玩家可以利用游戏内的各种资源进行创造，搭建自己的世界。

在 Minecraft 中，基本的建筑元素是边长为 1 个单位的立方体，小蒜想用 N个这种小立方体搭建一个长方体，并用他珍藏已久的贴纸对其进行装饰。如果一张贴纸可以贴满小立方体的一个面。那么，他需要用掉多少张贴纸呢？

### 输入格式

一个整数 N，表示小明所拥有的小立方体的个数。N 不会超过 1000。

### 输出格式

一个整数，即小明最少用掉的贴纸有多少张。

输出时每行末尾的多余空格，不影响答案正确性

### 样例输入

```c
9
```

### 样例输出

```c
30
```
### **分析：**
乍一看是一道寻找规律的题，拿着笔画了十几分钟图也没有规律可循。不行那就换个思路，仔细看了下数据范围n<=1000,我们可以用三个嵌套for循环来遍历长方体的长宽高，但是这样的话尽管n不是太大但时间复杂度也高达o（n^3），显然这样的代码一点也不美，我们需要优化一下：我们知道假如长方体的边长为i,j,k的话那么V体=i*j*k,S表=2ij+2ik+2jk。根据体积公式我们完全可以用两个循环加一个判断来实现遍历：
### **基本框架：**



```c
for(i=1;i<=n;i++)
{
    for(j=1;j<=n;j++)
    {
        if(n%(i*j)==0)//满足条件的一种长和宽
        {
         k=n/(i*j);//对应的高
         /.../
        }
    }
}
```
### **小插曲：**
框架一出来这道题就迎刃而解了，本着严谨的态度在我们遍历的时候i,j的大范围都是<=n的(正方体与正方体重合的面最少的一种情况)，那么我们再思考一下，我们可不可以缩小i,j即长和宽的遍历范围？我们知道我们用掉的贴纸数量其实就是组合成大长方体的表面积，我们给出的n即需要的正方体个数，那么存在不存在一种特殊情况：我们给定的n可能除了小正方体摆成一行的情况凑不成一个长方体。对于这种情况而言，组成的长方体的长或宽或高就达到了边界值n。因此对于此种解法而言，我认为i,j的遍历范围不能缩小，仅且能<=n。
下面是ac代码：

```c
#include<stdio.h>
int main()
{
int n;
int min=99999;
scanf("%d",&n);
//i,j,k,m:长,宽,高,表面积（所需贴纸）
int i,j,k,m;
for(i=1;i<=n;i++)
{
    for(j=1;j<=n;j++)
    {
        if(n%(i*j)==0)//寻找合法长和宽
        {
         k=n/(i*j);//此长宽对应的高
        m=2*(i*j+i*k+j*k);//贴纸数
        if(m<min)
        {
            min=m;//寻找最小解
        }
        }
    }
}
printf("%d",min);
return 0;
```
